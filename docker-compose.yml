# version: "3.8"
services:
  # 1) MySQL database
  mysql:
    container_name: my-mysql-container
    image: mysql:5.7
    ports:
    # 表示将宿主机的 3307 端口映射到容器内部的 3306 端口（MySQL 默认端口）。
    # 注意：如果你的后端应用运行在宿主机上连接数据库，则需要连接宿主机的 3307 端口；
    # 如果后端应用也在同一个 Docker 网络中，则建议使用容器名称和内部端口（3306）进行连接。
      - "3306:3306"
    environment:
    # 设置 MySQL 容器初始化时的环境变量：

    # MYSQL_ROOT_PASSWORD: "123456"
    # 在容器第一次启动时（且数据目录为空时），MySQL 会自动设置 root 用户的密码为 123456。
    # 无需你手动先创建账号，MySQL 镜像会根据这个变量自动完成初始化。
    # MYSQL_DATABASE: "webCloud"
    # 同样，在第一次启动时会自动创建一个名为 webCloud 的数据库。
    # 如果你还需要额外创建普通用户（非 root），可以再添加环境变量：
    # MYSQL_USER: <用户名>
    # MYSQL_PASSWORD: <密码>
      MYSQL_ROOT_PASSWORD: "123456"
      MYSQL_DATABASE: "webCloud"
    volumes:
      # 这行配置的作用是将容器内的 MySQL 数据存储目录映射到名为 db_data 的 Docker 卷上，以便实现数据持久化。
      # 如果注释掉这一行，容器每次启动都会使用全新的数据目录，所有之前创建的数据都会丢失。所以建议保留这一行配置，除非你有特殊需求。
#      - db_data:/var/lib/mysql
      - ./init-scripts:/docker-entrypoint-initdb.d  # 挂载初始化脚本
    networks:
    # 指定该服务加入名为 app-network 的 Docker 网络。
    # 如果你的其他服务（比如 Spring Boot 后端）也加入这个网络，则它们可以通过容器名称直接互相通信，而不需要通过宿主机的端口映射。
      - app-network


  # # 2) Redis cache
  # redis:
  #   container_name: my-redis-container
  #   image: redis:6.2
  #   command: redis-server --requirepass root@123456
  #   ports:
  #     - "6379:6379"
  #   networks:
  #     - app-network

  # 3) backend (Spring Boot)
  backend:
    container_name: my-backend-container
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "8080:8080"
    # environment:
     
    #   SPRING_DATASOURCE_URL: "jdbc:mysql://mysql:3306/webCloud?serverTimezone=UTC"
    #   SPRING_DATASOURCE_USERNAME: "root"
    #   SPRING_DATASOURCE_PASSWORD: "123456"

    #   SPRING_REDIS_HOST: "redis"
    #   SPRING_REDIS_PORT: 6379
    #   SPRING_REDIS_PASSWORD: "root@123456"

    #   # you can add other environment variables, such as
    #   # SPRING_DATASOURCE_DRIVER_CLASS_NAME: com.mysql.cj.jdbc.Driver
    #   # ...
    # depends_on:
    #   - mysql
    #   - redis
    networks:
      - app-network

#   # 4) frontend (React)
#   frontend:
#     container_name: my-frontend-container
#     build:
#       context: ./frontend
#       dockerfile: Dockerfile
#     # if you use npm run build + serve in Dockerfile
#     # the service will be provided on port 3000 in the container
#     ports:
#       - "3000:3000"
#     depends_on:
#       - backend
#     networks:
#       - app-network

#   # 5) Nginx
#   nginx:
#     container_name: my-nginx-container
#     image: nginx:alpine
#     # mount your custom configuration file to /etc/nginx/conf.d/default.conf
#     volumes:
#       - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf:ro

#     # if you want Nginx to serve the frontend static files, you can copy or mount the build content
#     # volumes:
#     #   - ./frontend/build:/usr/share/nginx/html:ro

#     depends_on:
#       - frontend
#       - backend
#     ports:
#       - "80:80"
#     networks:
#       - app-network

# self-defined network, so that containers can access each other by service name
networks:
  app-network:
    driver: bridge
